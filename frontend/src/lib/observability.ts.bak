import { trace, context, SpanStatusCode, Span } from '@opentelemetry/api';
import { registerInstrumentations } from '@opentelemetry/instrumentation';
import { getWebAutoInstrumentations } from '@opentelemetry/auto-instrumentations-web';
import { WebTracerProvider } from '@opentelemetry/sdk-trace-web';
import { Resource } from '@opentelemetry/resources';
import { ATTR_SERVICE_NAME, ATTR_SERVICE_VERSION } from '@opentelemetry/semantic-conventions';
import { BatchSpanProcessor } from '@opentelemetry/sdk-trace-base';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';

const isClient = typeof window !== 'undefined';

let initialized = false;

export function initializeFrontendObservability() {
  if (!isClient || initialized || process.env.NODE_ENV !== 'production') {
    return;
  }

  const resource = new Resource({
    [ATTR_SERVICE_NAME]: 'smartpick-frontend',
    [ATTR_SERVICE_VERSION]: process.env.NEXT_PUBLIC_APP_VERSION || '0.1.0',
    'deployment.environment': process.env.NODE_ENV || 'development',
  });

  const provider = new WebTracerProvider({ resource });

  const exporter = new OTLPTraceExporter({
    url: process.env.NEXT_PUBLIC_OTEL_EXPORTER_OTLP_ENDPOINT
      ? `${process.env.NEXT_PUBLIC_OTEL_EXPORTER_OTLP_ENDPOINT}/v1/traces`
      : undefined,
  });

  provider.addSpanProcessor(new BatchSpanProcessor(exporter));
  provider.register();

  registerInstrumentations({
    instrumentations: [
      getWebAutoInstrumentations({
        '@opentelemetry/instrumentation-document-load': {},
        '@opentelemetry/instrumentation-user-interaction': {
          eventNames: ['click', 'submit'],
        },
        '@opentelemetry/instrumentation-fetch': {
          propagateTraceHeaderCorsUrls: [/^http:\/\/localhost:\d+/],
        },
      }),
    ],
  });

  initialized = true;
  console.log('Frontend observability initialized');
}

const tracer = trace.getTracer('smartpick-frontend');

export async function traceApiCall<T>(
  name: string,
  attributes: Record<string, string | number>,
  fn: () => Promise<T>,
): Promise<T> {
  if (!isClient) return fn();

  return tracer.startActiveSpan(name, async (span: Span) => {
    Object.entries(attributes).forEach(([key, value]) => {
      span.setAttribute(key, value);
    });

    try {
      const result = await fn();
      span.setStatus({ code: SpanStatusCode.OK });
      return result;
    } catch (error) {
      span.setStatus({
        code: SpanStatusCode.ERROR,
        message: error instanceof Error ? error.message : 'Unknown error',
      });
      span.recordException(error as Error);
      throw error;
    } finally {
      span.end();
    }
  });
}

export function recordUserInteraction(
  action: string,
  target: string,
  metadata?: Record<string, string | number>,
) {
  if (!isClient) return;

  tracer.startActiveSpan('user.interaction', (span: Span) => {
    span.setAttribute('action', action);
    span.setAttribute('target', target);
    
    if (metadata) {
      Object.entries(metadata).forEach(([key, value]) => {
        span.setAttribute(`metadata.${key}`, value);
      });
    }
    
    span.setStatus({ code: SpanStatusCode.OK });
    span.end();
  });
}
